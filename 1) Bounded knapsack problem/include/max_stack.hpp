// Реализация стека с поддержкой максимального элемента
#pragma once // директива препроцессора, предназначенная для предотвращения многократного включения одного и того же заголовочного файла

#include <cassert> // для отлова логических багов
#include <stack> // для использования стека (на двух стеках реализована очередь)

// Для реализации стека с поддержкой поиска максимального элемента можно использовать два стека: один для хранения элементов стека, а другой для хранения текущих максимальных значений. 
// Когда добавляется новый элемент в обычный стек, проверяется, является ли он больше (или равен) текущего максимума (если да — добавляем элемент в стек максимумов, иначе — нет). 
// При извлечении элемента из основного стека также проверяется, является ли он равным верхнему элементу стека максимумов, и если да, то они удаляются оба, если нет — то только элемент из основного стека.
template <typename T> // шаблон для работы с разными типами данных
class MaxStack {
    private:
        std::stack<T> stack_data; // обычный стек
        std::stack<T> stack_max; // стек, хранящий максимальные значения


    public:
        // Конструктор класса.
        MaxStack() {}

        // Деструктор класса.
        ~MaxStack() {}

        // Метод для добавления элемента наверх стека.
        void push(T value) {
            stack_data.push(value); // добавляем значение в стек
            if (stack_max.empty() || value >= stack_max.top()) { // если stack_max пуст или новое значение больше или равно текущему максимуму, добавляем его в stack_max
                stack_max.push(value); // добавляем значение в стек максимумов
            }
        }

        // Метод для удаления элемента с верхушки стека.
        void pop() {
            // if (stack_data.empty()) { // если стек с данными пуст
            //     throw std::runtime_error("Stack is empty!"); // выкидываем ошибку
            // }
            assert(!stack_data.empty()); // если стек с данными пуст — выкидываем ошибку

            if (stack_data.top() == stack_max.top()) { // если верхний элемент основного стека равен верхнему элементу stack_max, удаляем его из stack_max
                stack_max.pop(); // удаляем верхний элемент стека с максимумами
            }
            stack_data.pop(); // удаляем верхний элемент стека с данными
        }

        // Метод для получения верхнего элемента стека.
        T top() const {
            // if (stack_data.empty()) { // если стек с данными пуст
            //     throw std::runtime_error("Stack is empty!"); // выкидываем ошибку
            // }
            assert(!stack_data.empty()); // если стек с данными пуст — выкидываем ошибку

            return stack_data.top(); // возвращаем верхушку стека
        }

        // Метод для получения максимального элемента стека.
        T get_max() const {
            // if (stack_max.empty()) { // если стек с максимумами пуст
            //     throw std::runtime_error("Stack of maximums is empty!"); // выкидываем ошибку
            // }
            assert(!stack_max.empty()); // если стек с максимумами пуст — выкидываем ошибку

            return stack_max.top(); // возвращаем верхушку стека максимумов
        }

        // Метод для получения размера стека.
        size_t get_size() const {
            return stack_data.size();
        }

        // Метод для проверки пустоты стека.
        bool empty() const {
            return stack_data.empty();
        }
};